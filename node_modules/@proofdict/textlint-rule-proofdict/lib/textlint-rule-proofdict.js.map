{"version":3,"sources":["../src/textlint-rule-proofdict.js"],"names":["require","RuleHelper","debug","DefaultOptions","dictURL","undefined","dictPath","autoUpdateInterval","whitelistTags","blacklistTags","proofdict","disableProofdictTesterCache","reporter","context","options","helper","Syntax","RuleError","report","getSource","fixer","Document","node","mode","MODE","NETWORK","LOCAL","Array","isArray","disableTesterCache","targetNodes","addQueue","push","promiseQueue","lastUpdated","Number","storage","getItem","isExpired","Date","now","jsonAPIURL","URL","then","dictionary","setItem","JSON","stringify","catch","error","Promise","resolve","Str","tester","promises","map","isChildNode","Link","Image","BlockQuote","Emphasis","text","match","result","details","forEach","detail","matchStartIndex","matchEndIndex","actual","expected","description","rule","url","additionalDescription","additionalReference","messages","index","fix","replaceTextRange","all","module","exports","linter"],"mappings":"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","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\nconst { RuleHelper } = require(\"textlint-rule-helper\");\nimport { createTester, getDictionary } from \"./create-tester\";\nimport { fetchProofdict } from \"./fetch-proofdict\";\nimport { getDictJSONURL, getRuleURL } from \"./proofdict-repo-util\";\nimport { MODE } from \"./mode\";\nimport { storage } from \"./dictionary-storage\";\n\nconst debug = require(\"debug\")(\"textlint-rule-proofdict\");\nconst DefaultOptions = {\n    // If you want to use live-proofdict\n    // Proofdict-style dictionary URL\n    // Example: \"https://example.github.io/proof-dictionary/\"\n    // If you want to specific JSON end point, please pass\n    // `dictURL; { jsonAPI: string, ruleBase: string }`\n    dictURL: undefined,\n    // If you want to use local proofdict\n    // dictPath is glob style path\n    // TODO: Not implement yet\n    dictPath: undefined,\n    // Default: 60sec(60 * 1000ms)\n    autoUpdateInterval: 60 * 1000,\n    // = Tag settings\n    // Filter dictionary by whitelist or blacklist\n    // Default: Enable all terms of the dictionary.\n    // When set both options, this rule prefer whitelist to blacklist\n    whitelistTags: [],\n    blacklistTags: [],\n    // For testing\n    // set you proofdict json object\n    proofdict: undefined,\n    // Disable cache for tester\n    disableProofdictTesterCache: false\n};\n\nconst reporter = (context, options = DefaultOptions) => {\n    const helper = new RuleHelper(context);\n    const { Syntax, RuleError, report, getSource, fixer } = context;\n    if (!options.dictURL && !options.dictPath && !options.proofdict) {\n        return {\n            [Syntax.Document](node) {\n                report(\n                    node,\n                    new RuleError(`Not found dictionary setting.\nPlease set dictURL or dictPath to .textlintrc.`)\n                );\n            }\n        };\n    }\n    const mode = options.dictURL ? MODE.NETWORK : MODE.LOCAL;\n    const whitelistTags = Array.isArray(options.whitelistTags) ? options.whitelistTags : DefaultOptions.whitelistTags;\n    const blacklistTags = Array.isArray(options.blacklistTags) ? options.blacklistTags : DefaultOptions.blacklistTags;\n    const disableTesterCache =\n        options.disableProofdictTesterCache !== undefined\n            ? options.disableProofdictTesterCache\n            : DefaultOptions.disableProofdictTesterCache;\n    const autoUpdateInterval =\n        options.autoUpdateInterval !== undefined ? options.autoUpdateInterval : DefaultOptions.autoUpdateInterval;\n    const targetNodes = [];\n    const addQueue = node => targetNodes.push(node);\n    let promiseQueue = null;\n    return {\n        [Syntax.Document]() {\n            // default: 0\n            const lastUpdated = Number(storage.getItem(\"proofdict-lastUpdated\", \"-1\"));\n            const isExpired = lastUpdated <= 0 ? true : Date.now() - lastUpdated > autoUpdateInterval;\n            if (mode === MODE.NETWORK && isExpired) {\n                const jsonAPIURL = getDictJSONURL(options);\n                promiseQueue = fetchProofdict({ URL: jsonAPIURL })\n                    .then(dictionary => {\n                        storage.setItem(\"proofdict\", JSON.stringify(dictionary));\n                        storage.setItem(\"proofdict-lastUpdated\", Date.now());\n                    })\n                    .catch(error => {\n                        debug(\"error is happened, but this rule fallback to storage\", error);\n                    });\n            } else {\n                promiseQueue = Promise.resolve();\n            }\n            return promiseQueue;\n        },\n        [Syntax.Str](node) {\n            addQueue(node);\n        },\n        [`${Syntax.Document}:exit`]() {\n            return promiseQueue.then(() => {\n                const dictionary = getDictionary(options, mode);\n                if (!dictionary) {\n                    debug(\"Can not fetch rules from local and network. stop to lint.\");\n                    return;\n                }\n                const lastUpdated = Number(storage.getItem(\"proofdict-lastUpdated\", \"0\"));\n                const tester = createTester({\n                    dictionary,\n                    lastUpdated,\n                    whitelistTags,\n                    blacklistTags,\n                    disableTesterCache\n                });\n                // check\n                const promises = targetNodes.map(node => {\n                    if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                        return;\n                    }\n                    const text = getSource(node);\n                    return tester.match(text).then(result => {\n                        result.details.forEach(detail => {\n                            const { matchStartIndex, matchEndIndex, actual, expected, description, rule } = detail;\n                            // If result is not changed, should not report\n                            if (actual === expected) {\n                                return;\n                            }\n                            const url = getRuleURL(options, rule);\n                            const additionalDescription = description ? `\\n${description}` : \"\";\n                            const additionalReference = url ? `\\nSee ${url}` : \"\";\n                            const messages = actual + \" => \" + expected + additionalDescription + additionalReference;\n                            report(\n                                node,\n                                new RuleError(messages, {\n                                    index: matchStartIndex,\n                                    fix: fixer.replaceTextRange([matchStartIndex, matchEndIndex], expected)\n                                })\n                            );\n                        });\n                    });\n                });\n                return Promise.all(promises);\n            });\n        }\n    };\n};\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"],"file":"textlint-rule-proofdict.js"}