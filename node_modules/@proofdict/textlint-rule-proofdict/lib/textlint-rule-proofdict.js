// MIT Â© 2017 azu
"use strict";

var _createTester = require("./create-tester");

var _fetchProofdict = require("./fetch-proofdict");

var _proofdictRepoUtil = require("./proofdict-repo-util");

var _mode = require("./mode");

var _dictionaryStorage = require("./dictionary-storage");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require("textlint-rule-helper"),
    RuleHelper = _require.RuleHelper;

var debug = require("debug")("textlint-rule-proofdict");

var DefaultOptions = {
  // If you want to use live-proofdict
  // Proofdict-style dictionary URL
  // Example: "https://example.github.io/proof-dictionary/"
  // If you want to specific JSON end point, please pass
  // `dictURL; { jsonAPI: string, ruleBase: string }`
  dictURL: undefined,
  // If you want to use local proofdict
  // dictPath is glob style path
  // TODO: Not implement yet
  dictPath: undefined,
  // Default: 60sec(60 * 1000ms)
  autoUpdateInterval: 60 * 1000,
  // = Tag settings
  // Filter dictionary by whitelist or blacklist
  // Default: Enable all terms of the dictionary.
  // When set both options, this rule prefer whitelist to blacklist
  whitelistTags: [],
  blacklistTags: [],
  // For testing
  // set you proofdict json object
  proofdict: undefined,
  // Disable cache for tester
  disableProofdictTesterCache: false
};

var reporter = function reporter(context) {
  var _ref2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultOptions;
  var helper = new RuleHelper(context);
  var Syntax = context.Syntax,
      RuleError = context.RuleError,
      report = context.report,
      getSource = context.getSource,
      fixer = context.fixer;

  if (!options.dictURL && !options.dictPath && !options.proofdict) {
    return _defineProperty({}, Syntax.Document, function (node) {
      report(node, new RuleError("Not found dictionary setting.\nPlease set dictURL or dictPath to .textlintrc."));
    });
  }

  var mode = options.dictURL ? _mode.MODE.NETWORK : _mode.MODE.LOCAL;
  var whitelistTags = Array.isArray(options.whitelistTags) ? options.whitelistTags : DefaultOptions.whitelistTags;
  var blacklistTags = Array.isArray(options.blacklistTags) ? options.blacklistTags : DefaultOptions.blacklistTags;
  var disableTesterCache = options.disableProofdictTesterCache !== undefined ? options.disableProofdictTesterCache : DefaultOptions.disableProofdictTesterCache;
  var autoUpdateInterval = options.autoUpdateInterval !== undefined ? options.autoUpdateInterval : DefaultOptions.autoUpdateInterval;
  var targetNodes = [];

  var addQueue = function addQueue(node) {
    return targetNodes.push(node);
  };

  var promiseQueue = null;
  return _ref2 = {}, _defineProperty(_ref2, Syntax.Document, function () {
    // default: 0
    var lastUpdated = Number(_dictionaryStorage.storage.getItem("proofdict-lastUpdated", "-1"));
    var isExpired = lastUpdated <= 0 ? true : Date.now() - lastUpdated > autoUpdateInterval;

    if (mode === _mode.MODE.NETWORK && isExpired) {
      var jsonAPIURL = (0, _proofdictRepoUtil.getDictJSONURL)(options);
      promiseQueue = (0, _fetchProofdict.fetchProofdict)({
        URL: jsonAPIURL
      }).then(function (dictionary) {
        _dictionaryStorage.storage.setItem("proofdict", JSON.stringify(dictionary));

        _dictionaryStorage.storage.setItem("proofdict-lastUpdated", Date.now());
      }).catch(function (error) {
        debug("error is happened, but this rule fallback to storage", error);
      });
    } else {
      promiseQueue = Promise.resolve();
    }

    return promiseQueue;
  }), _defineProperty(_ref2, Syntax.Str, function (node) {
    addQueue(node);
  }), _defineProperty(_ref2, "".concat(Syntax.Document, ":exit"), function exit() {
    return promiseQueue.then(function () {
      var dictionary = (0, _createTester.getDictionary)(options, mode);

      if (!dictionary) {
        debug("Can not fetch rules from local and network. stop to lint.");
        return;
      }

      var lastUpdated = Number(_dictionaryStorage.storage.getItem("proofdict-lastUpdated", "0"));
      var tester = (0, _createTester.createTester)({
        dictionary: dictionary,
        lastUpdated: lastUpdated,
        whitelistTags: whitelistTags,
        blacklistTags: blacklistTags,
        disableTesterCache: disableTesterCache
      }); // check

      var promises = targetNodes.map(function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
          return;
        }

        var text = getSource(node);
        return tester.match(text).then(function (result) {
          result.details.forEach(function (detail) {
            var matchStartIndex = detail.matchStartIndex,
                matchEndIndex = detail.matchEndIndex,
                actual = detail.actual,
                expected = detail.expected,
                description = detail.description,
                rule = detail.rule; // If result is not changed, should not report

            if (actual === expected) {
              return;
            }

            var url = (0, _proofdictRepoUtil.getRuleURL)(options, rule);
            var additionalDescription = description ? "\n".concat(description) : "";
            var additionalReference = url ? "\nSee ".concat(url) : "";
            var messages = actual + " => " + expected + additionalDescription + additionalReference;
            report(node, new RuleError(messages, {
              index: matchStartIndex,
              fix: fixer.replaceTextRange([matchStartIndex, matchEndIndex], expected)
            }));
          });
        });
      });
      return Promise.all(promises);
    });
  }), _ref2;
};

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-proofdict.js.map