// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _objectAssign = require("object-assign");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var splitAST = require("sentence-splitter").splitAST;
var SentenceSyntax = require("sentence-splitter").Syntax;

var defaultOptions = {
    interval: 2
};
var PointingPattern = /[、,]/;

// conjunction
/**
 * get first node value
 * @param node
 * @returns {string}
 */
function getFirstPhrase(node) {
    if (!PointingPattern.test(node.value)) {
        return "";
    }
    var phrases = node.value.split(PointingPattern);
    if (phrases.length > 0) {
        return phrases[0].trim();
    }
    return "";
}

module.exports = function (context) {
    var _ref;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    options = (0, _objectAssign2.default)({}, defaultOptions, options);
    var helper = new _textlintRuleHelper.RuleHelper(context);
    var ignoreNodeManager = new _textlintRuleHelper.IgnoreNodeManager();
    var Syntax = context.Syntax,
        getSource = context.getSource,
        report = context.report,
        RuleError = context.RuleError;

    var previousPhases = [];
    var useDuplicatedPhase = false;
    var addUsedPhase = function addUsedPhase(phase) {
        // Add first item
        previousPhases.unshift(phase);
        // slice by interval
        // max limit `interval`
        previousPhases = previousPhases.slice(0, options.interval);
    };
    return _ref = {}, _defineProperty(_ref, Syntax.Header, function () {
        previousPhases = [];
    }), _defineProperty(_ref, Syntax.HorizontalRule, function () {
        previousPhases = [];
    }), _defineProperty(_ref, Syntax.Paragraph, function (node) {
        // FIXME: linkReference should be defined in TxtAST.
        var ignoreTypes = [Syntax.Code, Syntax.Link, "linkReference", Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis];
        if (helper.isChildNode(node, ignoreTypes)) {
            return;
        }
        ignoreNodeManager.ignoreChildrenByTypes(node, ignoreTypes);
        var sentences = splitAST(node).children.filter(function (sentence) {
            return sentence.type === SentenceSyntax.Sentence;
        });
        sentences.forEach(function (sentence) {
            var firstChild = sentence.children[0];
            if (!firstChild) {
                return addUsedPhase("");
            }
            if (firstChild.type !== Syntax.Str) {
                return addUsedPhase("");
            }
            var phrase = getFirstPhrase(firstChild);
            // add first item
            if (phrase.length === 0) {
                return addUsedPhase("");
            }
            if (previousPhases.indexOf(phrase) !== -1) {
                useDuplicatedPhase = true;
            }
            if (useDuplicatedPhase) {
                // adjust index
                // if  "また、[import, a.js](a.js)" then originalIndex is used.
                // if "[import, binary-example.js](src/binary-example.js)" then  originalIndex is undefined.
                if (!ignoreNodeManager.isIgnored(firstChild)) {
                    report(firstChild, new RuleError("Don't repeat \"" + phrase + "\" in " + options.interval + " phrases"));
                }
                useDuplicatedPhase = false;
            }
            addUsedPhase(phrase);
        });
    }), _ref;
};
//# sourceMappingURL=no-start-duplicated-conjunction.js.map